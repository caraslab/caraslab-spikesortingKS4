function [mat_file] = caraslab_gpufilter_matfile(mat_file, ops)
    %caraslab_kilosort(datadir,sel)
    %
    %This function applies a chunkwise gpufilter on a matfile (Kilosort implementation)
    % Matfile has to be Ch (rows) x Samples (columns)
    % It's done before kilosort so we can correctly output a filtered file
    % to be visualized in phy
    %
    %Input variables:
    %
    %       datadir: path to folder containing data directories. Each directory
    %                should contain a binary (-dat) data file and
    %                a kilosort configuration (config.mat) file. Both of
    %                these files are generated by caraslab_createconfig.m
    %
    %       sel:    if 0 or omitted, program will cycle through all folders
    %               in the data directory.    
    %
    %               if 1, program will prompt user to select folder
    %
    %Written by MML 08/24/20

    %Load in configuration file (contains ops struct)
    % Catch error if -mat file is not found

    % Load config paramaters
    [chanMap, xc, yc, kcoords, NchanTOTdefault] = loadChanMap(ops.chanMap); % function to load channel map file
    ops.NchanTOT = getOr(ops, 'NchanTOT', NchanTOTdefault); % if NchanTOT was left empty, then overwrite with the default
    
    NchanTOT = ops.NchanTOT; % total number of channels in the raw binary file, including dead, auxiliary etc
    
    if isfield(ops, 'igood')
        igood = ops.igood;  % Good channels
    else
        igood = 1:NchanTOT;
    end
    
    if isfield(ops, 'badchannels')
        igood(ops.badchannels) = 0;
    end

    NT       = ops.NT ; % number of timepoints per batch

    nTimepoints = size(mat_file, 2); % number of total timepoints
    ops.tstart  = ceil(ops.trange(1) * ops.fs); % starting timepoint for processing data segment
    ops.tend    = min(nTimepoints, ceil(ops.trange(2) * ops.fs)); % ending timepoint
    ops.sampsToRead = ops.tend-ops.tstart; % total number of samples to read
    ops.twind = ops.tstart; % skip this many samples at the start

    Nbatch      = ceil(ops.sampsToRead /NT); % number of data batches
    ops.Nbatch = Nbatch;
    NTbuff      = NT + 4*ops.ntbuff; % we need buffers on both sides for filtering

    % set up the parameters of the filter
    if isfield(ops,'fslow')&&ops.fslow<ops.fs/2
        [b1, a1] = butter(3, [ops.fshigh/ops.fs,ops.fslow/ops.fs]*2, 'bandpass'); % butterworth filter with only 3 nodes (otherwise it's unstable for float32)
    else
        [b1, a1] = butter(3, ops.fshigh/ops.fs*2, 'high'); % the default is to only do high-pass filtering at 150Hz
    end

    if getOr(ops, 'comb', 0)  % MML edit; comb filter
        N  = 407;    % Order
        BW = 2;    % Bandwidth
        Fs = ops.fs;  % Sampling Frequency
        h = fdesign.comb('Notch', 'N,BW', N, BW, Fs);
        comb_filter = design(h, 'butter');
        comb_b1= comb_filter.Numerator;
        comb_a1= comb_filter.Denominator;
    end

    %Start timer
    tic;
    for ibatch = 1:Nbatch
        % we'll create a binary file of batches of NT samples, which overlap consecutively on ops.ntbuff samples
        % in addition to that, we'll read another ops.ntbuff samples from before and after, to have as buffers for filtering
        offset = max(0, ops.twind + (NT*(ibatch-1) - 2*ops.ntbuff)); % number of samples to start reading at.
        if offset==0
            ioffset = 0; % The very first batch has no pre-buffer, and has to be treated separately
        else
            ioffset = 2*ops.ntbuff;
        end
        

        if offset + NTbuff >= nTimepoints
            buff = mat_file(:, offset:end);
            nsampcurr = size(buff,2); % how many time samples the current batch has
            buff(:, nsampcurr+1:NTbuff) = repmat(buff(:,nsampcurr), 1, NTbuff-nsampcurr); % pad with zeros, if this is the last batch
        else
            buff = mat_file(:, offset + (1:NTbuff));
        end
        
        if isempty(buff)
            break; % this shouldn't really happen, unless we counted data batches wrong
        end
        
        % Finally start filtering...
        % Can't use GPU acceleration for comb filter yet...
        if getOr(ops, 'comb', 0)  % MML edit; comb filter
            buff = buff';  % MML edit: transpose sooner
            buff = filter(comb_b1, comb_a1, buff);
            dataRAW = gpuArray(buff); % move int16 data to GPU
        else
            dataRAW = gpuArray(buff); % move int16 data to GPU
            dataRAW = dataRAW';
        end

        dataRAW = single(dataRAW); % convert to float32 so GPU operations are fast
        % subtract the mean from each channel
        dataRAW = dataRAW - mean(dataRAW, 1); % subtract mean of each channel

        % CAR, common average referencing by median
        if getOr(ops, 'CAR', 1)
            % MML edit:take median of good channels only
            dataRAW = dataRAW - median(dataRAW(:, chanMap(igood)), 2); % subtract median across channels
        end

        datr = filter(b1, a1, dataRAW); % causal forward filter

        datr = flipud(datr); % reverse time
        datr = filter(b1, a1, datr); % causal forward filter again
        datr = flipud(datr); % reverse time back

    %     datr    = gpufilter(buff, ops, ops.chanMap(ops.igood), 1); % apply filters and median subtraction
        % FOR DEBUG
    %     datr = dataRAW;

        datr    = datr(ioffset + (1:NT),:); % remove timepoints used as buffers

        % DEBUG
    %     a = datr(end-100:end, 1);    
    % %     b = datr(1:101, 1);
    %     figure
    %     hold on
    %     plot([a_pre b_pre])
    %     plot([a; b])
    %     
        datr = datr';

        datr  = gather(datr); % convert to int16, and gather on the CPU side
        
        if offset + NT >= nTimepoints
            % Last batch
            mat_file(:,offset:end) = datr(:,1:nTimepoints-offset+1);
        else
            mat_file(:,offset+(1:NT)) = datr;
        end
    end
    tEnd = toc;
    fprintf('Done in: %d minutes and %f seconds\n', floor(tEnd/60), rem(tEnd,60));
end
